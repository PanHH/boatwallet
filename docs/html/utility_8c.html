<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Boat Wallet: utility.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Boat Wallet
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">An Ethereum compatible wallet C SDK for IoT</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('utility_8c.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">utility.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="boattypes_8h_source.html">wallet/boattypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="utility_8h_source.html">utilities/utility.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac728ab918934cb209ceec70e4be64940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utility_8c.html#ac728ab918934cb209ceec70e4be64940">UtilityTrimBin</a> (<a class="el" href="boattypes_8h.html#a25bdee88a6bea456316f8cb7fed42138">BOAT_OUT</a> <a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *to_ptr, const <a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *from_ptr, <a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> from_len, <a class="el" href="utility_8h.html#a470174e9056509fec2fa7646d62ccb66">TRIMBIN_TRIM_MODE</a> trim_mode, <a class="el" href="boattypes_8h.html#aefdb61570c9b3bd96efaac05b5d0f127">BOATBOOL</a> zero_as_null)</td></tr>
<tr class="memdesc:ac728ab918934cb209ceec70e4be64940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim zeros of a binary stream.  <a href="#ac728ab918934cb209ceec70e4be64940">More...</a><br /></td></tr>
<tr class="separator:ac728ab918934cb209ceec70e4be64940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6972b2d492a3c131d693af08797bad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utility_8c.html#a6e6972b2d492a3c131d693af08797bad">UtilityBin2Hex</a> (<a class="el" href="boattypes_8h.html#a25bdee88a6bea456316f8cb7fed42138">BOAT_OUT</a> <a class="el" href="boattypes_8h.html#aebb9e13210d88d43e32e735ada43a425">CHAR</a> *to_str, const <a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *from_ptr, <a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> from_len, <a class="el" href="utility_8h.html#a12a5a3456f47bcce11eda67ca3f9d518">BIN2HEX_TRIM_MODE</a> trim_mode, <a class="el" href="utility_8h.html#a66da4f24ba8c7dd83aea3102435b8890">BIN2HEX_PREFIX_0x_MODE</a> prefix_0x_mode, <a class="el" href="boattypes_8h.html#aefdb61570c9b3bd96efaac05b5d0f127">BOATBOOL</a> zero_as_null)</td></tr>
<tr class="memdesc:a6e6972b2d492a3c131d693af08797bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a binary stream to HEX string with optional leading zeros trimming and "0x" prefix.  <a href="#a6e6972b2d492a3c131d693af08797bad">More...</a><br /></td></tr>
<tr class="separator:a6e6972b2d492a3c131d693af08797bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e324a119ad6207ad8eed1dd2ac9858b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utility_8c.html#a5e324a119ad6207ad8eed1dd2ac9858b">UtilityHex2Bin</a> (<a class="el" href="boattypes_8h.html#a25bdee88a6bea456316f8cb7fed42138">BOAT_OUT</a> <a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *to_ptr, <a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> to_size, const <a class="el" href="boattypes_8h.html#aebb9e13210d88d43e32e735ada43a425">CHAR</a> *from_str, <a class="el" href="utility_8h.html#a470174e9056509fec2fa7646d62ccb66">TRIMBIN_TRIM_MODE</a> trim_mode, <a class="el" href="boattypes_8h.html#aefdb61570c9b3bd96efaac05b5d0f127">BOATBOOL</a> zero_as_null)</td></tr>
<tr class="memdesc:a5e324a119ad6207ad8eed1dd2ac9858b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a HEX string to binary stream with optional leading zeros trimming.  <a href="#a5e324a119ad6207ad8eed1dd2ac9858b">More...</a><br /></td></tr>
<tr class="separator:a5e324a119ad6207ad8eed1dd2ac9858b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10137d642f5eaff08986377e97dda33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utility_8c.html#af10137d642f5eaff08986377e97dda33">UtilityUint32ToBigend</a> (<a class="el" href="boattypes_8h.html#a25bdee88a6bea456316f8cb7fed42138">BOAT_OUT</a> <a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *to_big_ptr, <a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> from_host_integer, <a class="el" href="utility_8h.html#a470174e9056509fec2fa7646d62ccb66">TRIMBIN_TRIM_MODE</a> trim_mode)</td></tr>
<tr class="memdesc:af10137d642f5eaff08986377e97dda33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a host endian UINT32 to bigendian with optional MSB zeros trimming.  <a href="#af10137d642f5eaff08986377e97dda33">More...</a><br /></td></tr>
<tr class="separator:af10137d642f5eaff08986377e97dda33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f531e479f439a97431b1e68a72e180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utility_8c.html#a85f531e479f439a97431b1e68a72e180">UtilityUint64ToBigend</a> (<a class="el" href="boattypes_8h.html#a25bdee88a6bea456316f8cb7fed42138">BOAT_OUT</a> <a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *to_big_ptr, <a class="el" href="boattypes_8h.html#aaaeacfdfbfc1dcaae18cf20e63015e71">UINT64</a> from_host_integer, <a class="el" href="utility_8h.html#a470174e9056509fec2fa7646d62ccb66">TRIMBIN_TRIM_MODE</a> trim_mode)</td></tr>
<tr class="memdesc:a85f531e479f439a97431b1e68a72e180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a host endian UINT64 to bigendian with optional MSB zeros trimming.  <a href="#a85f531e479f439a97431b1e68a72e180">More...</a><br /></td></tr>
<tr class="separator:a85f531e479f439a97431b1e68a72e180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8a759a3b33396ff9fe10f602d6f37f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utility_8c.html#a8c8a759a3b33396ff9fe10f602d6f37f">Utilityhtonl</a> (<a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> from_host_integer)</td></tr>
<tr class="memdesc:a8c8a759a3b33396ff9fe10f602d6f37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a host endian UINT32 to bigendian.  <a href="#a8c8a759a3b33396ff9fe10f602d6f37f">More...</a><br /></td></tr>
<tr class="separator:a8c8a759a3b33396ff9fe10f602d6f37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ddd6d4a7312830f3571c15775c7ea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utility_8c.html#ab6ddd6d4a7312830f3571c15775c7ea9">Utilityntohl</a> (<a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> from_big_integer)</td></tr>
<tr class="memdesc:ab6ddd6d4a7312830f3571c15775c7ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a bigendian UINT32 to host endian.  <a href="#ab6ddd6d4a7312830f3571c15775c7ea9">More...</a><br /></td></tr>
<tr class="separator:ab6ddd6d4a7312830f3571c15775c7ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745b81eca690ac3838e3da2fa8c8fe72"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utility_8c.html#a745b81eca690ac3838e3da2fa8c8fe72">BoatMalloc</a> (<a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> size)</td></tr>
<tr class="memdesc:a745b81eca690ac3838e3da2fa8c8fe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for memory allocation.  <a href="#a745b81eca690ac3838e3da2fa8c8fe72">More...</a><br /></td></tr>
<tr class="separator:a745b81eca690ac3838e3da2fa8c8fe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01dd2ee3605f424e09b826ca7322b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utility_8c.html#af01dd2ee3605f424e09b826ca7322b3d">BoatFree</a> (void *mem_ptr)</td></tr>
<tr class="memdesc:af01dd2ee3605f424e09b826ca7322b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for memory allocation.  <a href="#af01dd2ee3605f424e09b826ca7322b3d">More...</a><br /></td></tr>
<tr class="separator:af01dd2ee3605f424e09b826ca7322b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a11c3ffc59501c83f037a2327d847b0fe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="boattypes_8h.html#aebb9e13210d88d43e32e735ada43a425">CHAR</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utility_8c.html#a11c3ffc59501c83f037a2327d847b0fe">g_log_level_name_str</a> []</td></tr>
<tr class="memdesc:a11c3ffc59501c83f037a2327d847b0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literal representation of log level.  <a href="#a11c3ffc59501c83f037a2327d847b0fe">More...</a><br /></td></tr>
<tr class="separator:a11c3ffc59501c83f037a2327d847b0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility functions. </p>
<p><a class="el" href="utility_8c.html" title="Utility functions. ">utility.c</a> contains utility functions for boatwallet. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af01dd2ee3605f424e09b826ca7322b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01dd2ee3605f424e09b826ca7322b3d">&#9670;&nbsp;</a></span>BoatFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BoatFree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for memory allocation. </p>
<hr/>
<p> Function: <a class="el" href="utility_8c.html#af01dd2ee3605f424e09b826ca7322b3d" title="Wrapper function for memory allocation. ">BoatFree()</a> </p><pre class="fragment">This function is a wrapper for dynamic memory de-allocation.

It typically wraps free() in a linux or Windows system.
For RTOS it depends on the specification of the RTOS.
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="utility_8c.html#a745b81eca690ac3838e3da2fa8c8fe72" title="Wrapper function for memory allocation. ">BoatMalloc()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This function doesn't return anything.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_ptr</td><td>The address to free. The address must be the one returned by <a class="el" href="utility_8c.html#a745b81eca690ac3838e3da2fa8c8fe72" title="Wrapper function for memory allocation. ">BoatMalloc()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a745b81eca690ac3838e3da2fa8c8fe72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745b81eca690ac3838e3da2fa8c8fe72">&#9670;&nbsp;</a></span>BoatMalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* BoatMalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for memory allocation. </p>
<hr/>
<p> Function: <a class="el" href="utility_8c.html#a745b81eca690ac3838e3da2fa8c8fe72" title="Wrapper function for memory allocation. ">BoatMalloc()</a> </p><pre class="fragment">This function is a wrapper for dynamic memory allocation.

It typically wraps malloc() in a linux or Windows system.
For RTOS it depends on the specification of the RTOS.
</pre><dl class="section return"><dt>Returns</dt><dd>This function returns the address of the allocated memory. If allocation<br />
 fails, it returns NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>How many bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e6972b2d492a3c131d693af08797bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6972b2d492a3c131d693af08797bad">&#9670;&nbsp;</a></span>UtilityBin2Hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> UtilityBin2Hex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#a25bdee88a6bea456316f8cb7fed42138">BOAT_OUT</a> <a class="el" href="boattypes_8h.html#aebb9e13210d88d43e32e735ada43a425">CHAR</a> *&#160;</td>
          <td class="paramname"><em>to_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *&#160;</td>
          <td class="paramname"><em>from_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>from_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utility_8h.html#a12a5a3456f47bcce11eda67ca3f9d518">BIN2HEX_TRIM_MODE</a>&#160;</td>
          <td class="paramname"><em>trim_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utility_8h.html#a66da4f24ba8c7dd83aea3102435b8890">BIN2HEX_PREFIX_0x_MODE</a>&#160;</td>
          <td class="paramname"><em>prefix_0x_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#aefdb61570c9b3bd96efaac05b5d0f127">BOATBOOL</a>&#160;</td>
          <td class="paramname"><em>zero_as_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a binary stream to HEX string with optional leading zeros trimming and "0x" prefix. </p>
<hr/>
<p> Function: <a class="el" href="utility_8c.html#a6e6972b2d492a3c131d693af08797bad" title="Convert a binary stream to HEX string with optional leading zeros trimming and &quot;0x&quot; prefix...">UtilityBin2Hex()</a> </p><pre class="fragment">This function converts a binary stream to a null-terminated HEX string.
Optionally leading zeros can be trimmed during conversion.
Optionally "0x" prefix can be prepended to the HEX string.

There is no space to delimit every HEX code.
The case of "a" through "f" is always lower case.

There are 3 ways to trim leading zeros. For example, a binary stream
{0x00, 0x01, 0x00, 0xAB} will be converted to string:

"000100ab": if &lt;trim_mode&gt; = BIN2HEX_TRIM_NO
"100ab"   : if &lt;trim_mode&gt; = BIN2HEX_LEFTTRIM_QUANTITY
"0100ab"  : if &lt;trim_mode&gt; = BIN2HEX_LEFTTRIM_UFMTDATA

Note that this function doesn't treat the binary stream as an integer and thus
it doens't make any endian conversion.
</pre><dl class="section return"><dt>Returns</dt><dd>This function returns the length of the converted HEX string excluding NULL<br />
 terminator. It equals to strlen of the string.<br />
 If &lt;to_str&gt; is NULL, this function does nothing and returns 0.<br />
 If &lt;from_len&gt; is 0 or &lt;from_ptr&gt; is NULL, and &lt;to_str&gt; is NOT NULL, this<br />
 function writes a '\0' to &lt;to_str&gt;, i.e. a NULL string and returns 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">to_str</td><td>The buffer to hold the converted HEX string.<br />
 Its size should be least &lt;from_len&gt;*2+1 bytes if &lt;prefix_0x_mode&gt;=BIN2HEX_PREFIX_0x_NO,<br />
 or &lt;from_len&gt;*2+3 bytes if &lt;prefix_0x_mode&gt;=BIN2HEX_PREFIX_0x_YES.<br />
 If &lt;to_str&gt; is NULL, this function does nothing and returns 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from_ptr</td><td>The binary stream to convert from.<br />
 If &lt;from_ptr&gt; is NULL and &lt;to_str&gt; is NOT NULL, this function writes a<br />
 '\0' to &lt;to_str&gt;, i.e. a NULL string and returns 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from_len</td><td>The length of &lt;from_ptr&gt; in byte.<br />
 If &lt;from_len&gt; is 0 and &lt;to_str&gt; is NOT NULL, this function writes a<br />
 '\0' to &lt;to_str&gt;, i.e. a NULL string and returns 1.</td></tr>
  </table>
  </dd>
</dl>
<p>[in] trim_mode BIN2HEX_TRIM_NO if no trimming is required;<br />
 BIN2HEX_LEFTTRIM_QUANTITY to trim as a quantity;<br />
 BIN2HEX_LEFTTRIM_UFMTDATA to trim as unformatted data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_0x_mode</td><td>BIN2HEX_PREFIX_0x_YES: Prepend a "0x" prefix at the beginning of the HEX string;<br />
 BIN2HEX_PREFIX_0x_NO: Don't prepend "0x" prefix.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">zero_as_null</td><td>In case the binary stream contains only one or multiple 0x00, if<br />
 &lt;zero_as_null&gt; is BOAT_TRUE, it will be converted to a null sting and<br />
 returns 0.<br />
 If &lt;zero_as_null&gt; is BOAT_FALSE, it will be converted to "0" or "00"<br />
 according to &lt;trim_mode&gt;.<br />
 &lt;zero_as_null&gt; should be BOAT_TRUE for RLP-Encoding purpose. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e324a119ad6207ad8eed1dd2ac9858b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e324a119ad6207ad8eed1dd2ac9858b">&#9670;&nbsp;</a></span>UtilityHex2Bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> UtilityHex2Bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#a25bdee88a6bea456316f8cb7fed42138">BOAT_OUT</a> <a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *&#160;</td>
          <td class="paramname"><em>to_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>to_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="boattypes_8h.html#aebb9e13210d88d43e32e735ada43a425">CHAR</a> *&#160;</td>
          <td class="paramname"><em>from_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utility_8h.html#a470174e9056509fec2fa7646d62ccb66">TRIMBIN_TRIM_MODE</a>&#160;</td>
          <td class="paramname"><em>trim_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#aefdb61570c9b3bd96efaac05b5d0f127">BOATBOOL</a>&#160;</td>
          <td class="paramname"><em>zero_as_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a HEX string to binary stream with optional leading zeros trimming. </p>
<hr/>
<p> Function: <a class="el" href="utility_8c.html#a5e324a119ad6207ad8eed1dd2ac9858b" title="Convert a HEX string to binary stream with optional leading zeros trimming. ">UtilityHex2Bin()</a></p>
<p>Description: This function converts a HEX string to a binary stream.</p>
<p>Optionally leading zeros can be trimmed during conversion.</p>
<p>If there is "0x" prefix at the beginning of the HEX string, it's ignored.</p>
<p>There should be no space between HEX codes.</p>
<p>If &lt;to_size&gt; is too small to hold the converted binary stream, only the beginning &lt;to_size&gt; bytes are converted and written to &lt;to_ptr&gt;.</p>
<p>The trim_mode is the same as <a class="el" href="utility_8c.html#ac728ab918934cb209ceec70e4be64940" title="Trim zeros of a binary stream. ">UtilityTrimBin()</a>. Odd length of HEX string is allowed as if it were left filled with a "0". For example, a HEX string "0x00123ab" is treated as "0x000123ab" and converted to: {0x01, 0x23, 0xab}: if &lt;trim_mode&gt; = TRIMBIN_LEFTTRIM; {0x00, 0x01, 0x23, 0xab}: if &lt;trim_mode&gt; = TRIMBIN_TRIM_NO</p>
<p>Note that this function doesn't treat the HEX string as an integer and thus it doens't make any endian conversion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="utility_8c.html#ac728ab918934cb209ceec70e4be64940" title="Trim zeros of a binary stream. ">UtilityTrimBin()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns how many bytes the converted binary stream is if the<br />
 conversion completes successfully. If the output buffer is too small to<br />
 hold the converted binary stream, it returns &lt;to_size&gt;.<br />
 If any non-HEX character is encountered, or &lt;from_str&gt; is an all-zero HEX<br />
 string and &lt;trim_mode&gt; is TRIMBIN_LEFTTRIM, it returns 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">to_ptr</td><td>The buffer to hold the converted binary stream.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_size</td><td>The size of &lt;to_ptr&gt; in bytes.<br />
 It's safe to ensure &lt;to_size&gt; &gt;= (strlen(from_str)+1)/2 bytes.<br />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from_str</td><td>The null-terminated HEX string to convert from. "0x" prefix is optional<br />
 and ignored. There should be no space between HEX codes.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trim_mode</td><td>TRIMBIN_LEFTTRIM: Trim leading zeros;<br />
 TRIMBIN_TRIM_NO: Don't trim.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero_as_null</td><td>In case the HEX string contains only one or multiple "00" and &lt;trim_mode&gt;<br />
 is TRIMBIN_LEFTTRIM, if &lt;zero_as_null&gt; is BOAT_TRUE, nothing will be<br />
 written to &lt;to_ptr&gt; and it returns 0.<br />
 If &lt;zero_as_null&gt; is BOAT_FALSE, it will be converted to a single 0x00<br />
 and returns 1.<br />
 &lt;zero_as_null&gt; should be BOAT_TRUE for RLP-Encoding purpose. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c8a759a3b33396ff9fe10f602d6f37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8a759a3b33396ff9fe10f602d6f37f">&#9670;&nbsp;</a></span>Utilityhtonl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> Utilityhtonl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>from_host_integer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a host endian UINT32 to bigendian. </p>
<hr/>
<p> Function: <a class="el" href="utility_8c.html#a8c8a759a3b33396ff9fe10f602d6f37f" title="Convert a host endian UINT32 to bigendian. ">Utilityhtonl()</a> </p><pre class="fragment">This function converts a host endian (typically littleendian) UINT32 integer
to bigendian.
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="utility_8c.html#af10137d642f5eaff08986377e97dda33" title="Convert a host endian UINT32 to bigendian with optional MSB zeros trimming. ">UtilityUint32ToBigend()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns the converted bigendian UINT32 integer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from_host_integer</td><td>The host endian UINT32 integer to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6ddd6d4a7312830f3571c15775c7ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ddd6d4a7312830f3571c15775c7ea9">&#9670;&nbsp;</a></span>Utilityntohl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> Utilityntohl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>from_big_integer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a bigendian UINT32 to host endian. </p>
<hr/>
<p> Function: <a class="el" href="utility_8c.html#a8c8a759a3b33396ff9fe10f602d6f37f" title="Convert a host endian UINT32 to bigendian. ">Utilityhtonl()</a> </p><pre class="fragment">This function converts a bigendian UINT32 integer to host endian (typically
littleendian).
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="utility_8c.html#a8c8a759a3b33396ff9fe10f602d6f37f" title="Convert a host endian UINT32 to bigendian. ">Utilityhtonl()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns the converted host endian UINT32 integer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from_big_integer</td><td>The big endian UINT32 integer to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac728ab918934cb209ceec70e4be64940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac728ab918934cb209ceec70e4be64940">&#9670;&nbsp;</a></span>UtilityTrimBin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> UtilityTrimBin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#a25bdee88a6bea456316f8cb7fed42138">BOAT_OUT</a> <a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *&#160;</td>
          <td class="paramname"><em>to_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *&#160;</td>
          <td class="paramname"><em>from_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>from_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utility_8h.html#a470174e9056509fec2fa7646d62ccb66">TRIMBIN_TRIM_MODE</a>&#160;</td>
          <td class="paramname"><em>trim_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#aefdb61570c9b3bd96efaac05b5d0f127">BOATBOOL</a>&#160;</td>
          <td class="paramname"><em>zero_as_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim zeros of a binary stream. </p>
<hr/>
<p> Function: <a class="el" href="utility_8c.html#ac728ab918934cb209ceec70e4be64940" title="Trim zeros of a binary stream. ">UtilityTrimBin()</a> </p><pre class="fragment">This function trims zeros of a binary stream and returns the length after
trimming. Currently only left trimming (i.e. trimming leading zeros) is
supported.

This function simply ignores leading zeros and copy the first non-zero byte
til the end of the stream to the target buffer. It doesn't treat the data
in buffer as integer, i.e. it doesn't care about the endian.

The source and target buffer may be overlapped.

For example, {0x00, 0x01, 0x02, 0x00} is trimed to {0x01, 0x02, 0x00} and
returns 3.
</pre><dl class="section return"><dt>Returns</dt><dd>This function returns how many bytes the trimmed binary stream is.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_ptr</td><td>A buffer to contain the trimmed binary stream. Its size must be at least &lt;from_len&gt; bytes. &lt;to_ptr&gt; and &lt;from_ptr&gt; may be overlapped.</td></tr>
    <tr><td class="paramname">from_ptr</td><td>The binary stream to trim. &lt;to_ptr&gt; and &lt;from_ptr&gt; may be overlapped.</td></tr>
    <tr><td class="paramname">from_len</td><td>Length of &lt;from_ptr&gt;.</td></tr>
    <tr><td class="paramname">trim_mode</td><td>Only TRIMBIN_LEFTTRIM is supported, i.e. trim leading zeros.<br />
 If TRIMBIN_TRIM_NO is specified, this function acts like memmove().</td></tr>
    <tr><td class="paramname">zero_as_null</td><td>In case the binary stream contains only one or multiple 0x00, if<br />
 &lt;zero_as_null&gt; is BOAT_TRUE, it will be treated as a null stream and<br />
 returns 0.<br />
 If &lt;zero_as_null&gt; is BOAT_FALSE, it will be trimed to a single 0x00 and<br />
 returns 1.<br />
 &lt;zero_as_null&gt; should be BOAT_TRUE for RLP-Encoding purpose. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af10137d642f5eaff08986377e97dda33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10137d642f5eaff08986377e97dda33">&#9670;&nbsp;</a></span>UtilityUint32ToBigend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> UtilityUint32ToBigend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#a25bdee88a6bea456316f8cb7fed42138">BOAT_OUT</a> <a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *&#160;</td>
          <td class="paramname"><em>to_big_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a>&#160;</td>
          <td class="paramname"><em>from_host_integer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utility_8h.html#a470174e9056509fec2fa7646d62ccb66">TRIMBIN_TRIM_MODE</a>&#160;</td>
          <td class="paramname"><em>trim_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a host endian UINT32 to bigendian with optional MSB zeros trimming. </p>
<hr/>
<p> Function: <a class="el" href="utility_8c.html#af10137d642f5eaff08986377e97dda33" title="Convert a host endian UINT32 to bigendian with optional MSB zeros trimming. ">UtilityUint32ToBigend()</a> </p><pre class="fragment">This function converts a host endian (typically littleendian) UINT32 integer
to bigendian.

Optionally most siganificant zeros can be trimmed during conversion.

The trim_mode is the same as UtilityTrimBin(). For example, a UINT32 integer
0x000123ab is converted to:
{0x01, 0x23, 0xab}: if &lt;trim_mode&gt; = TRIMBIN_LEFTTRIM;
{0x00, 0x01, 0x23, 0xab}: if &lt;trim_mode&gt; = TRIMBIN_TRIM_NO
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="utility_8c.html#ac728ab918934cb209ceec70e4be64940" title="Trim zeros of a binary stream. ">UtilityTrimBin()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns how many bytes the converted bigendian integer is.<br />
 If &lt;trim_mode&gt; = TRIMBIN_TRIM_NO, it always returns 4.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">to_big_ptr</td><td>The buffer to hold the converted binary stream.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from_host_integer</td><td>The host endian UINT32 integer to convert.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trim_mode</td><td>TRIMBIN_LEFTTRIM: Trim MSB zeros;<br />
 TRIMBIN_TRIM_NO: Don't trim. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85f531e479f439a97431b1e68a72e180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f531e479f439a97431b1e68a72e180">&#9670;&nbsp;</a></span>UtilityUint64ToBigend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> UtilityUint64ToBigend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#a25bdee88a6bea456316f8cb7fed42138">BOAT_OUT</a> <a class="el" href="boattypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *&#160;</td>
          <td class="paramname"><em>to_big_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="boattypes_8h.html#aaaeacfdfbfc1dcaae18cf20e63015e71">UINT64</a>&#160;</td>
          <td class="paramname"><em>from_host_integer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utility_8h.html#a470174e9056509fec2fa7646d62ccb66">TRIMBIN_TRIM_MODE</a>&#160;</td>
          <td class="paramname"><em>trim_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a host endian UINT64 to bigendian with optional MSB zeros trimming. </p>
<hr/>
<p> Function: <a class="el" href="utility_8c.html#a85f531e479f439a97431b1e68a72e180" title="Convert a host endian UINT64 to bigendian with optional MSB zeros trimming. ">UtilityUint64ToBigend()</a> </p><pre class="fragment">This function converts a host endian (typical littleendian) UINT64 integer
to bigendian.

Optionally most siganificant zeros can be trimmed during conversion.

It's a 64-bit version of UtilityUint32ToBigend(). 
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="utility_8c.html#af10137d642f5eaff08986377e97dda33" title="Convert a host endian UINT32 to bigendian with optional MSB zeros trimming. ">UtilityUint32ToBigend()</a> <a class="el" href="utility_8c.html#ac728ab918934cb209ceec70e4be64940" title="Trim zeros of a binary stream. ">UtilityTrimBin()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns how many bytes the converted bigendian integer is.<br />
 If &lt;trim_mode&gt; = TRIMBIN_TRIM_NO, it always returns 8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">to_big_ptr</td><td>The buffer to hold the converted binary stream.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from_host_integer</td><td>The host endian UINT64 integer to convert.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trim_mode</td><td>TRIMBIN_LEFTTRIM: Trim MSB zeros;<br />
 TRIMBIN_TRIM_NO: Don't trim. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a11c3ffc59501c83f037a2327d847b0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c3ffc59501c83f037a2327d847b0fe">&#9670;&nbsp;</a></span>g_log_level_name_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="boattypes_8h.html#aebb9e13210d88d43e32e735ada43a425">CHAR</a>* const g_log_level_name_str[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= </div><div class="line">{</div><div class="line">    <span class="stringliteral">&quot;LOG_CRITICAL&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;LOG_NORMAL&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;LOG_VERBOSE&quot;</span></div><div class="line">}</div></div><!-- fragment -->
<p>Literal representation of log level. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_7b5d38f1875f1b693f62ca6a108a1129.html">utilities</a></li><li class="navelem"><a class="el" href="utility_8c.html">utility.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
